'''

KMP算法理论基础

'''

'''
KMP应用：
    主要应用于字符串的匹配，能够有效地降低时间复杂度。当出现字符串不匹配的时候，可以利用之前已经匹配到的一些字符，避免重复匹配这个操作。
    
KMP的主要元素：模式串的前缀表。
    什么是模式串？什么是文本串？
        文本串相当于题目的题干，模式串相当于选项，你需要在题干中找到该选项的出处。例如文本串是：aabba，模式串是ab，所以可以在文本串中找到模式串。
    什么是前缀表？
        记录下标之前子串的最长公共前后缀。例如aabba的前缀表是01001，如何求出来的
            当指针指向第一个a的时候，初始化前缀表，没有前后缀，所以为0
            当指针指向第二个a的时候，此时子字符串为aa，前缀a，后缀a，最长公共前后缀长度为1
            当指针指向第三个b的时候，此时子字符串为aab，前缀有a,aa,后缀有ab,b，两者没有公共前后缀，所以为0
            当指针指向第四个b的时候，此时子字符串为aabb，前缀有a，aa，aab，后缀有abb，bb，b。没有公共前后缀，所以为0
            当指针指向第五个a的时候，此时子字符串为aabba，前缀有a，aa，aab，aabb，后缀有abba，bba，ba，a。所以公共前后缀为a，长度为1
        一般将01001整体向左移动一位，变成-1,0,1,0,0
    求出前缀表的步骤：
        1.初始化next列表，jk指针
        2.处理前后缀相同的情况
        3.处理前后缀不同的情况
'''

# 如何求出一个字符串的前缀表
def getnext(n:int,moshichuan:list):
    '''
    这个函数就是来求模式串的前缀表
    :param n: 模式串的长度
    :param moshichuan: 给定的模式串
    :return: 输出next数组
    '''
    next = ['' for i in range(n)] # 先创建一个空的前缀表
    j,k = 0,-1 # 给定两个指针，j一直向前移动，不会后退，而k则不停辗转。next数组只能由next[j]决定
    next[0] = k # 初始化前缀表
    while j < n -1:
        if k == -1 or moshichuan[j] == moshichuan[k]:
            '''
            当k == -1说明k已经后退到最后的尽头了,需要将jk两个指针同时向前移动一位，并且添加next[j]的值
            当moshichuan[j] == moshichuan[k]，说明前面的子串有公共的区域，可以拿来使用，避免重复比对，jk两个指针同时向前移动一位，然后添加next[j]的值
            '''
            j += 1
            k += 1
            next[j] = k
        else:
            k = next[k] # 假如没有满足上面的两个条件中任意一个，就会被返回到该指针下next列表里的值的位置，用来尽可能寻找公共串，来减少时间复杂度
    #                       不断循环，直到找到重复的公共串或者k被返回到最开始位置
    return next
