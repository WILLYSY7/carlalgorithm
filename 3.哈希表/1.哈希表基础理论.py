'''
哈希表基础理论
'''
'''
3.哈希表 hash table，或者叫散列表：
    哈希表能够根据关键码的值直接访问数据的数据结构。数组就是一个哈希表，数组的索引下标就是哈希表的关键码。
    哈希表的边界范围 [0,tableSize - 1]

哈希表的作用：
    哈希表可以用来快速判断一个元素是否出现在集合中，若用枚举法，时间复杂度为O(n)，用哈希表，则时间复杂度为O(1)。

哈希函数：
    哈希函数是通过hashCode把元素转化为数值。hashCode通过特定的编码方式，
    可以将其他数据格式转化为不同的数值，这样元素就映射到了哈表的索引数字上了。
    index = hashFunction(values)    hashFunction = hashCode(values) % tableSize
    (如何保证所有索引数值都落在哈希表上，一般会通过对数值做一个取模处理，保证index一定可以映射到哈希表上)

哈希碰撞：
    如果values的值太多，映射在同一个index上，则需要哈希碰撞来解决这个问题。一般哈希碰撞有两种解决方法
    拉链法：
        在发生冲突的index后面创建一个链表，这样就能够通过索引找到对应的values
        拉链法需要选择适当的哈希表大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而花费大量时间在查找上
    线性探测法：
        用线性探测法要保证tableSize大于dataSize。需要用表中的空位来处理碰撞问题。
        如果两个values放置的位置冲突了，那么就向下找一个空位置放置另外一个value的值。

常见的三种哈希结构：
    1.数组，set，map
    在C++中，
        std::set key有序，数值不能重复，不能更改数值，查询效率增删效率都为logn     底层实现是红黑树
        std::multiset key有序，数值能重复，不能更改数值，查询效率增删效率都为logn     底层实现是红黑树
        std::unordered_set key无序，数值不能重复，不能更改数值，查询效率增删效率都为1      底层实现是哈希表
        同理：
        std::map key有序，key不能重复，key不能修改，查询效率增删效率都为logn     底层实现是红黑树
        std::multimap key有序，key能重复，key不能修改，查询效率增删效率都为logn     底层实现是红黑树
        std::unordered_map key无序，key不能重复，key不能修改，查询效率增删效率都为logn     底层实现是哈希表
        
如果我们要快速判断一个元素是否出现在集合中，要考虑使用哈希法
        
'''