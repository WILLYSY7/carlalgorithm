'''

涉及到的题目
leetcode 739

'''

'''
平时如何想到要去使用单调栈
* 通常是一维数组，要寻找任一个元素的右边或者左边第一个比自己大或者小的元素的位置，此时我们就要想到可以用单调栈了。 *
单调栈可以把时间复杂度降低到O(n)
那么单调栈的原理是什么呢？为什么时间复杂度是O(n)就可以找到每一个元素的右边第一个比它大的元素位置呢？
单调栈的本质是空间换时间，因为在遍历的过程中需要用一个栈来记录右边第一个比当前元素高的元素，优点是只需要遍历一次。

在使用单调栈的时候首先要明确如下几点：
    1.单调栈里放的是元素的下标，而不是元素，这样如果我们需要元素，直接用下标来获取对应元素即可
    2.求大值：从栈头到栈底应该是递增的。因为只有递增，我们新遍历的元素才能从小到大循序渐进地对比。
        例如每日温度这样，遇到了更大的元素，栈里面相对较小的元素遇到了比它本身大的元素，这样我们就可以填上answer
        这些栈里待处理的元素被pop，成为已经处理了的状态，然而更大的元素进栈变成未处理状态，需要之后继续寻找更大的值
    求小值：从栈头到栈底应该是递减的。
'''


'''
leetcode 739
739. 每日温度
给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer ，
其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 0 来代替。

示例 1:
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]

示例 2:
输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]

示例 3:
输入: temperatures = [30,60,90]
输出: [1,1,0]
'''
'''
利用单调栈的话，需要明白的几点是：
1，栈里存的是坐标index
2，三种状况要考虑
    1）元素大于栈顶元素：pop栈顶元素，填写answer表格更新答案，同时继续判断，直到栈空或者没有遇到更小的元素，将该元素入栈
    2）元素小于栈顶元素：直接将元素入栈，其他不改变，成为待处理元素
    3）元素等于栈顶元素：同2）
'''
class Solution:
    def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
        stack = [0] # 初始化栈，将第一个温度下标入栈
        ans = [0 for _ in range(len(temperatures))]
        for i in range(1, len(temperatures)): # 从第二个元素开始比较
            if temperatures[i] <= temperatures[stack[-1]]:
                stack.append(i) # 元素变为待处理状态
            else:
                while stack and temperatures[i] > temperatures[stack[-1]]:
                    ans[stack[-1]] = i - stack[-1] # 处理元素，填写答案表格
                    stack.pop() # 释放已处理的元素
                stack.append(i) # 将大元素入栈，变为待处理状态
        return ans


