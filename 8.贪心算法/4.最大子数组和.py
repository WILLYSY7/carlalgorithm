'''

涉及到的题目
LeetCode 53

'''
'''
leetcode 53
给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
子数组 是数组中的一个连续部分。

示例 1：
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组[4,-1,2,1] 的和最大，为6 。

示例 2：
输入：nums = [1]
输出：1

示例 3：
输入：nums = [5,4,-1,7,8]
输出：23

https://leetcode.cn/problems/maximum-subarray

'''
# 这道题如果用两个for循环来解决，会导致时间复杂度太高然后超时。
#     具体解题的思想是：当开始遍历的时候，如果一开始都是负数，那么直接跳过，从正数开始计数，因为增加负数只会减小数组和
#                    如果当前计算的总和为负数，那么立马开始新的计算。
#                       将之前算出来的负数要么舍弃（有比该负数更大的和），要么将这个负数暂时认定为当前最大值，然后重新开始计算。
#                    原因在于一个负数再加后面的数，数值肯定会减小的，直接从头开始计算，这样只用遍历一次。
'''
局部最优：当前连续和为负数的时候立刻放弃计算，从下一个元素开始重新计算连续和。因为负数加上下一个元素只会导致连续和减小
全局最优：选取最大的连续和
这个操作相当于在暴力解法中不断调整最大子序列和区间的起始位置。
最后遍历结束就是遍历到头，然后返回记录的最大值
'''
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        max_num  = -float('inf') # float('inf')加一个负号，代表负无穷
        temp = 0 # 当前计算的连续和，可能会随时放弃掉，所以是一个暂时值
        for i in range(len(nums)):
            temp += nums[i]
            if temp > max_num:
                max_num = temp
            if temp <= 0:
                temp = 0
        return max_num