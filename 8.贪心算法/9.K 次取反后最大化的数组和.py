'''

涉及到的题目
leetcode 1005

'''
'''
1005. K 次取反后最大化的数组和
给你一个整数数组 nums 和一个整数 k ，按以下方法修改该数组：
选择某个下标 i 并将 nums[i] 替换为 -nums[i] 。
重复这个过程恰好 k 次。可以多次选择同一个下标 i 。
以这种方式修改数组后，返回数组 可能的最大和 。

示例 1：
输入：nums = [4,2,3], k = 1
输出：5
解释：选择下标 1 ，nums 变为 [4,-2,3] 。

示例 2：
输入：nums = [3,-1,0,2], k = 3
输出：6
解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。

示例 3：
输入：nums = [2,-3,-1,5,-4], k = 2
输出：13
解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。
'''
# 第一次贪心：局部最优：让绝对值大的负数变为正数，当前数值达到最大，整体最优：整个数组和达到最大。
# 处理之后，如果K依然大于0，此时的问题是一个有序正整数序列，如何转变K次正负，让 数组和 达到最大。
# 第二次贪心：局部最优：只找数值最小的正整数进行反转，当前数值可以达到最大
# （例如正整数数组{5, 3, 1}，反转1 得到-1 比 反转5得到的-5 大多了），全局最优：整个 数组和 达到最大。
class Solution:
    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:
        # 将数组重新组合，并且以绝对值最大倒序排序
        new_nums = sorted(nums, key = abs, reverse = True)
        for i in range(len(new_nums)):
            # 如果数组中有负数，就先将复数转成整数
            if k > 0 and new_nums[i] < 0:
                new_nums[i] *= -1
                k -= 1
        if k > 0:
            # 若有多余的k，则不断转换最小数即可
            new_nums[-1] *= (-1)**k
        return sum(new_nums)