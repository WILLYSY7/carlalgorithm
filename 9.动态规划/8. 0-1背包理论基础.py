'''

0-1 背包理论基础

'''
'''
0-1背包的描述
有N件物品和一个最多能承受重量为W的背包，第i件物品的重量是weight[i]，得到的价值是value[i]
每件物品只能用一次，求解将哪些物品装入背包后物品价值的总和最大

对于暴力解法，每个物品都有两个状态取或者不取，利用回溯算法可以求出物品价值的最大总和
但是这种解法的时间复杂度为2^n,n为物品的数量，是一个指数级别的算法，需要用动态规划来优化
'''
############################################
#
#       背包承重： 4
#                 重量          价值
#   物品0           1            15
#   物品1           3            20
#   物品2           4            30
#
############################################
'''
利用dp五部曲来解决这个问题
1、确定dp数组以及下标的含义
二维数组 dp[i][j]  其中i为物品index，j为背包的重量
    则dp[i][j]的含义就是你当前能取的物品只有0-i，当前你只有一个小背包，所能拿到的最大价值（先解决这些小问题，再解决最终的大问题）
    而此时你就会作出两个不一样的选择，为了确定dp[i][j]的值，此时我已经有了dp[i-1][j]的价值
    那我其中一个选择就是不拿i，我当前的价值和上一个状态相比不变
           另外一个选择就是拿i，拿i就代表着我要腾出一部分的空间来放i，因为我拿了i，背包的价值肯定有一部分是value[i]
            现在背包还剩下的空间是[j-weight[i]]，那么剩下的空间最多能装多大的价值呢，那就是dp[i-1][j-weight[i]]
            此时我们就推导出了递推公式
                dp[i][j] = max(dp[i-1][j], value[i] + dp[i-i][j-weight[i]])
    初始化的操作，当背包空间为0的时候，不管i为多少，价值都为0，因为一个也装不了
                当一开始i为0的时候，说明只能拿这一件，再容量允许的范围内，价值都是该物品i本身的价值
                初始化的两个for循环可以替换位置
    
'''