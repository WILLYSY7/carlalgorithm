'''

涉及到的题目
leetcode 1043

'''
'''
1043. 分隔数组以得到最大和
给你一个整数数组 arr，请你将该数组分隔为长度最多为 k 的一些（连续）子数组。分隔完成后，每个子数组的中的所有值都会变为该子数组中的最大值。
返回将数组分隔变换后能够得到的元素最大和。

注意，原数组和分隔后的数组对应顺序应当一致，也就是说，你只能选择分隔数组的位置而不能调整数组中的顺序。

示例 1：
输入：arr = [1,15,7,9,2,5,10], k = 3
输出：84
解释：
因为 k=3 可以分隔成 [1,15,7] [9] [2,5,10]，结果为 [15,15,15,9,10,10,10]，和为 84，是该数组所有分隔变换后元素总和最大的。
若是分隔成 [1] [15,7,9] [2,5,10]，结果就是 [1, 15, 15, 15, 10, 10, 10] 但这种分隔方式的元素总和（76）小于上一种。 

示例 2：
输入：arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4
输出：83

示例 3：
输入：arr = [1], k = 1
输出：1
'''

'''
此题需要注意的是题目理解要到位，其中k代表的是子数组的长度最长不能超过k，所以我们可以选择的子数组串的长度为[0,k]左闭右闭
首先我们创建dp数组，dp表示到当前坐标i，arr[:i+1]这个数组能组成的最大和为dp[i]
那么我们需要一个长度为n的一维dp数组。

首先第一个for 循环，指针为i，目的是为了遍历所有长度，以填满dp数组，是一个主循环

其次，在每一个主循环下面，我们再加入一个次循环while，这个while可以理解为一个动态的窗口，从当前坐标i向前延伸，框选住长度小于等于k的子数组
次循环的指针用j来表示，且j一定小于等于i，假设当前j合法，指向了arr[j]，那么由i和j可以构成一个子串，并且维护子串里的最大值和子串长度
我们就可以求出该子串的合法最大值，那么我们再加上j之前数组组成的最大值即dp[j-1]，就可以求出当前dp[i]的值

由于j一直向前延伸，每次延伸一格就要更新一次dp[i]的最大值，一旦这个窗口的长度大于k就break，然后移动i开始填写下一个dp

'''

class Solution:
    def maxSumAfterPartitioning(self, arr: List[int], k: int) -> int:
        n = len(arr)
        dp = [0 for _ in range(n)]
        dp[0] = arr[0]
        if n == 1: return dp[0]
        for i in range(1, n):
            temp_max = 0
            l = 0
            j = i
            while j >= 0:
                l += 1
                if l > k:
                    break
                temp_max = max(temp_max, arr[j])
                if j-1 >= 0:
                    dp[i] = max(dp[i], dp[j-1] + temp_max*l)
                else:
                    dp[i] = max(dp[i], temp_max*l)
                j -= 1
        return dp[-1]
