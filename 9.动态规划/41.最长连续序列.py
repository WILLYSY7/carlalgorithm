'''

涉及到的题目
leetcode 128

'''
'''
leetcode 128
128. 最长连续序列
给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
请你设计并实现时间复杂度为 O(n) 的算法解决此问题。

示例 1：
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。

示例 2：
输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9
'''
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        '''首先，定义一个哈希表（用于判断某个数是否存在哈希表中）
            然后遍历数组, 如果当前数num存在哈希表，那么跳过
            如果当前数num不存在哈希表中，那么查找num-1和num+1这两个数是不是在哈希表中
            比如 num是5
            1234 678都在哈希表中
            遍历数组的时候，遇到1234678都会掠过
            此时哈希表中，1的位置和4存的值都是4（证明1或者4所在的连续长度是4）
            同理 6和8存的值都是3
            那么此时5进来之后，看看4和6在不在哈希表内，如果在的话，一定是端点，一定能获取到值
            所以5进来之后，发现左边有4个连续的，右边有3个连续的，加上自己一个，那么组成一个大连续的
            4+1+3 = 8
            所以要更新当前最长连续串的端点，也就是1的位置（5-4），8的位置（5+3），更新长度为8
            只需要端点存值就行，因为端点中的值在遍历的时候如果在哈希表中就会略过
            如果这个时候9又进来，那么它获取到8的位置有8，10的位置有0
            更新连续子串长度（8+1+0）
            所以更新左端点1（9-8）的值为9，右端点9（9+0）的值为9'''
        hash_dict = dict()# 哈希表中的元素表示包含该元素的最长连续序列长度
        res = 0
        for num in nums:
            if num not in hash_dict:
                    # 如果num在哈希表中就跳过，不在哈希表中就开始进行判断
                left_len = hash_dict.get(num-1, 0)
                    # 寻找num左边是否存在连续数，如果存在返回左边最长延伸的长度，如果不存在返回0
                right_len = hash_dict.get(num+1, 0)
                    # 寻找num右边是否存在连续数，如果存在返回右边最长延伸的长度，如果不存在返回0

                cur_len = 1 + left_len + right_len # 记录下来包含当前num所能组成的最长连续序列长度
                res = max(res, cur_len) # 记录最长长度

                hash_dict[num] = cur_len # 同时更新长度
                hash_dict[num-left_len] = cur_len # 最左端点更新长度
                hash_dict[num+right_len] = cur_len # 最右端点更新长度
        return res