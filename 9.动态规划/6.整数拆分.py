'''

涉及到的题目
leetcode 343

'''
'''
leetcode 343
343. 整数拆分
给定一个正整数 n ，将其拆分为 k 个 正整数 的和（ k >= 2 ），并使这些整数的乘积最大化。
返回 你可以获得的最大乘积 。

示例 1:
输入: n = 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。

示例 2:
输入: n = 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
'''


class Solution:
    def integerBreak(self, n: int) -> int:
        '''贪心算法，将一个不小于4的整数拆成由3组成的各个数的和，再相乘，结果就是最大的'''
        if n <=3: return n-1
        if n == 4: return 4
        temp = 1
        while n >= 5:
            temp *= 3
            n -= 3
        res = temp * n
        return res

class Solution:
    def integerBreak(self, n: int) -> int:
        '''动态规划：我们不知道每次要拆几，那么就从1开始试，试到n-1，求出单次拆获得的乘积最大
        dp[i]代表着第i个数能获得的最大乘积，那么这个dp[i]获得的方式只有两种，
        一种是只拆一次，相乘；另外一种是拆n次，相乘。取最大的情况。'''
        dp = [0] * (n+1)
        # dp[0] 和dp[1]无意义，因为不存在拆分的情况所以没有初始值
        dp[2] = 1 # 1+1=2 1*1 =1
        for i in range(3,n+1): # 0-2无意义
            for j in range(1, i-1): # 每次要拆几不知道，那么我们就一个一个试
                dp[i] = max(max((i-j)*j , dp[i-j]*j), dp[i])
                # 其中(i-j)*j就是只拆一次，例如dp[10] =（10-3）*3 = 21 （当j=3的情况）
                #   dp[i-j]*j表明我拆了不止一次。 dp[10-3] = dp[7] 而dp[7]有很多种不同的拆法，最后找到了最优的拆法dp[7] = 2*2*3
                #  那么dp[7]*3=36.此时就能算出dp[10]为36 （当j=3的情况）
                #  至于j可以取1-9，那就要一个一个试
                # 得到临时最大dp[i]的时候还要跟原本最大dp[i]作比较，最终才能求出在i-1种情况下求得的最大值
        return dp[n]