'''

涉及到的题目
leetcode 96

'''
'''
leetcode 96
96. 不同的二叉搜索树
给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。

示例 1：
输入：n = 3
输出：5

示例 2：
输入：n = 1
输出：1
'''
# 本题需要思考的是，给定的序列是一个递增序列，例如n=3，那么有五种情况，三个节点的值分别为1,2,3
# 但是想想其他的情况，如果三个节点是2,3,4 或者7,8,9，情况依旧只有五种，只要这三个数是递增的
# 那么就说明情况的个数只与n有关，与节点具体什么数值没关系
# 一棵二叉搜索树，其父节点的左侧对应递增序列的前i项，其父节点的右侧对应递增序列的i+1到尾项
#  dp[i]表示当n为i时所有的情况，那么dp[1]=1 dp[2]=2
#   假设以[1,2,3]为例
#   父节点可以为1,可以为2,可以为3.
#     当父节点为1时：左子树为空,右子树有两个元素分别为(2,3) 对应的情况有1*2=2种 （这个时候默认dp[0]=1,否则相乘为0）
#     当父节点为2时：左子树为1，右子树为3，对应的情况有1*1=1种
#     当父节点为3时：左子树有两个元素分别为（1,2），右子树为空，对应的情况有2*1=2种
#     所以dp[3] = 2+1+2=5
# 因此我们计算dp[4]的时候会发现，父节点有四个选项，每个选项都是左右子树的情况乘积，最后将四个不同的情况相加
# 推广到dp[i], 我们可以用指针j来遍历1到i， 每次当j为父节点的时候，左子树的情况是dp[j-1] 右子树的情况是dp[i-j]
# 相乘再累加，得到递推公式  dp[i] += dp[j-1]*dp[i-j]
# 从而我们能算出最终的结果

class Solution:
    def numTrees(self, n: int) -> int:
        if n <= 2: return n
        dp = [0] * (n+1)
        dp[0], dp[1], dp[2] = 1, 1, 2

        for i in range(3,n+1):
            for j in range(1,i+1):
                dp[i] += dp[j-1]*dp[i-j]

        return dp[n]